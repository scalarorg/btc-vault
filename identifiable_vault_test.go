package btcvault_test

import (
	"math/rand"
	"testing"

	"github.com/babylonchain/babylon/btcstaking"
	btcvault "github.com/scalarorg/btc-vault"

	"github.com/btcsuite/btcd/btcec/v2/schnorr"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/btcsuite/btcd/wire"
	"github.com/stretchr/testify/require"

	"github.com/babylonchain/babylon/testutil/datagen"
)

func generateTxFromOutputs(r *rand.Rand, info *btcvault.IdentifiableVaultInfo) *wire.MsgTx {
	tx := wire.NewMsgTx(2)
	tx.AddTxOut(info.VaultOutput)
	tx.AddTxOut(info.OpReturnOutput)
	tx.AddTxOut(info.PayloadOutput)
	tx.AddTxOut(wire.NewTxOut((r.Int63n(1000000000) + 10000), datagen.GenRandomByteArray(r, 32)))
	return tx
}

// Based on Babylon test
// from github.com/babylonchain/babylon/btcstaking/identifiable_staking_test.go
// Property: Every staking tx generated by our generator should be properly parsed by
// our parser
func FuzzGenerateAndParseValidV0StakingTransaction(f *testing.F) {
	// lot of seeds as test is pretty fast and we want to test a lot of different values
	datagen.AddRandomSeedsToFuzzer(f, 1000)
	f.Fuzz(func(t *testing.T, seed int64) {
		r := rand.New(rand.NewSource(seed))
		// 3 - 10 covenants
		numCovenantKeys := uint32(r.Int31n(7) + 3)
		quroum := uint32(r.Intn(int(numCovenantKeys)) + 1)
		stakingAmount := btcutil.Amount(r.Int63n(1000000000) + 10000)
		tag := datagen.GenRandomByteArray(r, btcstaking.TagLen)
		net := &chaincfg.MainNetParams
		chainID := datagen.GenRandomByteArray(r, 8)
		chainIdUserAddress := datagen.GenRandomByteArray(r, 20)
		chainIdSmartContractAddress := datagen.GenRandomByteArray(r, 20)
		vaultAmount := datagen.GenRandomByteArray(r, 32)
		sc := GenerateTestScenario(r, t, 1, numCovenantKeys, quroum, stakingAmount)
		// check value each field
		// fmt.Print("tag: ", tag, "\n")
		// fmt.Print("stakingAmount: ", stakingAmount, "\n")
		// fmt.Print("quroum: ", quroum, "\n")
		// fmt.Print("chainID: ", chainID, "\n")
		// fmt.Print("chainIdUserAddress: ", chainIdUserAddress, "\n")
		// fmt.Print("chainIdSmartContractAddress: ", chainIdSmartContractAddress, "\n")
		// fmt.Print("vaultAmount: ", vaultAmount, "\n")
		// fmt.Print("sc.StakerKey: ", sc.StakerKey, "\n")
		// fmt.Print("sc.FinalityProviderKeys[0]: ", sc.FinalityProviderKeys[0], "\n")
		// fmt.Print("sc.CovenantPublicKeys(): ", sc.CovenantPublicKeys(), "\n")
		// fmt.Print("sc.FinalityProviderKeys[0].PubKey(): ", sc.FinalityProviderKeys[0].PubKey(), "\n")
		outputs, err := btcvault.BuildV0IdentifiableVaultOutputs(
			tag,
			sc.StakerKey.PubKey(),
			sc.FinalityProviderKeys[0].PubKey(),
			sc.CovenantPublicKeys(),
			quroum,
			stakingAmount,
			chainID,
			chainIdUserAddress,
			chainIdSmartContractAddress,
			vaultAmount,
			net,
		)

		require.NoError(t, err)

		require.NotNil(t, outputs)

		tx := generateTxFromOutputs(r, outputs)
		// ParseV0StakingTx and IsPossibleV0StakingTx should be consistent and recognize
		// the same tx as a valid staking tx
		require.True(t, btcvault.IsPossibleV0VaultTx(tx, tag))
		parsedTx, err := btcvault.ParseV0VaultTx(
			tx,
			tag,
			sc.CovenantPublicKeys(),
			quroum,
			net,
		)
		require.NoError(t, err)
		require.NotNil(t, parsedTx)

		// test vault address
		require.Equal(t, outputs.VaultOutput.PkScript, parsedTx.VaultOutput.PkScript)
		require.Equal(t, outputs.VaultOutput.Value, parsedTx.VaultOutput.Value)

		// test first op_return
		require.Equal(t, outputs.OpReturnOutput.PkScript, parsedTx.OpReturnOutput.PkScript)
		require.Equal(t, outputs.OpReturnOutput.Value, parsedTx.OpReturnOutput.Value)

		// test tag and version
		require.Equal(t, tag, parsedTx.OpReturnData.Tag)
		require.Equal(t, uint8(0), parsedTx.OpReturnData.Version)

		// test second op_return
		require.Equal(t, outputs.PayloadOutput.PkScript, parsedTx.PayloadOutput.PkScript)
		require.Equal(t, outputs.PayloadOutput.Value, parsedTx.PayloadOutput.Value)

		// test chainID, chainIdUserAddress, chainIdSmartContractAddress, vaultAmount
		require.Equal(t, chainID, parsedTx.PayloadOpReturnData.ChainID)
		require.Equal(t, chainIdUserAddress, parsedTx.PayloadOpReturnData.ChainIdUserAddress)
		require.Equal(t, chainIdSmartContractAddress, parsedTx.PayloadOpReturnData.ChainIdSmartContractAddress)
		require.Equal(t, vaultAmount, parsedTx.PayloadOpReturnData.Amount)

		// test finality provider and covenant keys
		require.Equal(t, schnorr.SerializePubKey(sc.StakerKey.PubKey()), parsedTx.OpReturnData.StakerPublicKey.Marshall())
		require.Equal(t, schnorr.SerializePubKey(sc.FinalityProviderKeys[0].PubKey()), parsedTx.OpReturnData.FinalityProviderPublicKey.Marshall())
	})
}

// TODO Negative test cases
